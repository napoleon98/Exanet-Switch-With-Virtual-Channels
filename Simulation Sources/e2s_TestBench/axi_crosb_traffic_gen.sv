  //each traffic generator creates a file, and writes in it, the various details 
  //of each packet generated by it. (the packet is randomly generated). it then
  //"tags" the address of this packet on the "CRC" part of the header which is not
  //used by the switch
  
  
  //need to selectivly use backpressuer
  //need to selectivly use "valid-drop"

`timescale 1ns/1ps
import exanet_crosb_pkg::*;
import exanet_pkg::*;

module exa_crosb_traffic_gen #(
	parameter prio_num	        = 2,
	parameter prio_val          = 0,
	parameter [127:0]tag        = 0,
	parameter vc_num            = 2,
	parameter dimension_x       = 4,
    parameter dimension_y       = 2,
    parameter dimension_z       = 2 
)(
    input           clk,
    input           resetn,
    input           i_work,
    input [21:0]    i_src_coord,
    input           dif_size_enable,
    input           dif_type_enable,
    input           fixed_dest_enable,
    input           fixed_header_vc_enable,
    input           delay_enable,
    input [4:0]     fixed_dest_x,
    input [4:0]     fixed_dest_y,
    input [4:0]     fixed_dest_z,
    input [4:0]     valid_drop_rate,
    input [4:0]     fixed_header_vc,
    exanet.master   exa
);

  integer fd;
  reg [999:0] filename;
  
  initial begin
    $sformat(filename, "traffic_gen_%0d.dat", tag);
    fd = $fopen(filename, "w");
    $fwrite(fd,"Let's start writting!!!!!!\n");
    
    $fclose(fd); 
  end
  final begin
    $fclose(fd); 
  end

  localparam IDDLE     = 5'b00001;
  localparam HEADER    = 5'b00010;
  localparam PAYLOAD   = 5'b00100;
  localparam FOOTER    = 5'b01000;
  localparam DELAY     = 5'b10000;

  localparam max_size = 16;
  localparam chanche_for_high_priority = 80 ; //out of 128
  
  logic [4:0] words_left_q;
  logic [4:0] words_left_d;

  logic [4:0] state_q;
  logic [4:0] state_d;

  exanet_header exa_header_t;
  exanet_footer exa_footer_t;
  
  typedef struct packed {
    logic [10: 0]  src;     
    logic [10: 0]  dst;     
    logic [0:  0]  prio;
    logic [63: 0]  timestamp;
  } baket_info_t;
   
   
  reg [127:0] cur_time_q      = 0;
  reg [1:0]  rand_2           = 0;
  reg [3:0]  rand_4_z         = 0;
  reg [3:0]  rand_4_y         = 0;
  reg [3:0]  rand_4_x         = 0;
  
  
  reg [6:0]  rand_7           = 0;
  reg [5:0]  rand_6           = 0;      //used for random delay between packets

  reg [7:0]  rand_8           = 0;
  reg [31:0] rand_32          = 0;
  reg [4:0]  rand_5           = 0; //used for valid delay
  reg [4:0]  rand_5_header_vc = 0;


  always @(posedge clk) begin
    rand_32          <= $random();
    rand_5           <= $random();
    rand_5_header_vc <= $urandom() % (prio_num*vc_num);
    if (exa.header_valid & exa.header_ready) begin      
      cur_time_q     = $time ;//it was <= but with that, currtime is one packet delayed
      rand_6         <= $urandom() % 10;
      rand_2         <= $random();
      rand_4_x       <= $urandom() % dimension_x;
      rand_4_y       <= $urandom() % dimension_y;
      rand_4_z       <= $urandom() % dimension_z;
      rand_7         <= $random();
      rand_8         <= $random();
    end  
  end  
  
  
  always @(posedge clk) begin
    if (!resetn) begin
      state_q      <=  IDDLE;
      words_left_q <=  max_size;
    end else begin
      state_q      <=  state_d;    
      words_left_q <=  words_left_d;
    end
  end   
  
  always_comb begin
    words_left_d = words_left_q;
  
    if (state_q == PAYLOAD) begin
      if ((exa.payload_ready == 1) & (exa.payload_valid == 1) )
        words_left_d = words_left_q -1 ; 
    end else if (state_q == HEADER) begin
      if (exa.header_ready == 1)
        words_left_d = (exa_header_t.size==0) ? 0 : ((exa_header_t.size - 1)>>4);  
    end 
  end
  
  reg [31:0] delay_counter;
  always @(posedge clk) begin
    if (!resetn)
      delay_counter <= 0;
    else begin
      if (state_q == DELAY)
        delay_counter <= delay_counter + 1;
      else
        delay_counter <= 0;  
    end
  
  end
  
    
  always_comb begin
    case (state_q)
      IDDLE:
        if (i_work) 
          state_d = HEADER;
        else
          state_d = IDDLE;    
      
      HEADER:
        if (exa.header_ready == 1)
          state_d = PAYLOAD;
        else
          state_d = HEADER;       
      
      PAYLOAD :
        if ( (words_left_q ==0 ) & (exa.payload_ready == 1) & (exa.payload_valid == 1) )
          state_d = FOOTER;
        else
          state_d = PAYLOAD;   
          
      FOOTER:
        if (exa.footer_ready == 1)
          if ((i_work == 1)&(!delay_enable))
            state_d = HEADER;
          else if ((i_work == 1)&(delay_enable))
            state_d = DELAY;
          else
            state_d = IDDLE;
        else
          state_d = FOOTER;              
      DELAY:
        if ((i_work)&(delay_counter == rand_6))
          state_d = HEADER;
        else if (!i_work)
          state_d = IDDLE;
        else 
          state_d = DELAY;
    endcase  
  end
  
  /*write down all the packet info you about to send*/
  
  /*if you want to change the size of memory be careful: a) when mem_pointer is reseted
                                                         b) when packet counter is reseted */
  reg  [127:0] MEM [23*128] ;/*it was 23*64*/ //up to 512 packets storage
  reg  [31:0]  mem_pointer = 0;
  
  //wire [127:0] display_addr = exa_header_t.addr[9:0];
  wire [127:0] display_dest_coord = exa_header_t.dest_coord;
  wire [127:0] display_prio = (exa_header_t.vc > (vc_num - 1)) ? 1 : 0;//prio_val;
  always @(posedge clk) begin
    if (exa.header_valid & exa.header_ready) begin
        fd = $fopen(filename, "a");
        $fwrite(fd,"HEADERRRR!!!!!!\n");
        $fwrite(fd,"%h\n",tag);         //from whom
        $fwrite(fd,"%h\n",pkt_counter); //which packet this is
        $fwrite(fd," Current time is %0d\n",cur_time_q);  //what was the time it got sent
       // $fwrite(fd,"%h\n",display_addr);  //the dest
        $fwrite(fd,"%h\n",display_dest_coord);
        //$fwrite(fd,"%h\n",display_prio);  //the prio
        $fwrite(fd,"%h\n",exa.data);     //the data
        $fflush(fd);
        $fclose(fd);
        MEM[mem_pointer] <= tag;
        mem_pointer = mem_pointer + 1;
        MEM[mem_pointer] <= pkt_counter;
        mem_pointer = mem_pointer + 1; 
             
        //MEM[mem_pointer] <= cur_time_q;
        /*save the input vc*/  
        MEM[mem_pointer] <= exa_header_t.vc;
        mem_pointer = mem_pointer + 1;
       // MEM[mem_pointer] <= display_addr;
        MEM[mem_pointer] <= display_dest_coord;
        mem_pointer = mem_pointer + 1;
        MEM[mem_pointer] <= display_prio;
        mem_pointer = mem_pointer + 1;
        MEM[mem_pointer] <= exa.data;
        mem_pointer = mem_pointer + 1;                 
    end 
  end
  always @(posedge clk) begin
    if (exa.payload_valid & exa.payload_ready) begin
        fd = $fopen(filename, "a");
        //$fwrite(fd,"PAYLOADDD!!!!!!\n");
        $fwrite(fd,"%h\n",exa.data);         //the data
        $fflush(fd);
        $fclose(fd);
        MEM[mem_pointer] <= exa.data;
        mem_pointer = mem_pointer + 1;         
    end 
  end  
  
  wire [4:0] words_to_reach_16 = (size_q == 0)? 15 : (15 - ((size_q - 1)>>4));
  reg [31:0] i;
  always @(posedge clk) begin
    if (exa.footer_valid & exa.footer_ready) begin
        /*when its time for a footer, make sure to first write xx to enough words to be 16..*/
        fd = $fopen(filename, "a");
        for (i = 0 ; i<words_to_reach_16 ; i++) begin
          MEM[mem_pointer] <= 128'h66666666666666666666666666666666;
          mem_pointer = mem_pointer + 1;
          $fwrite(fd,"%h\n",128'h66666666666666666666666666666666);
        end
        MEM[mem_pointer] <= exa.data;
        if (mem_pointer == 2943)//it was 1471    //1024*23 - 1)
          mem_pointer = 0;
        else
          mem_pointer = mem_pointer + 1;  
          
        //$fwrite(fd,"FOOTERRRR!!!!!!\n");      
        $fwrite(fd,"%h\n",exa.data);         //the data
        $fflush(fd);
        $fclose(fd);  
    end 
  end  
  
  
  reg [127:0] pkt_counter = 0;
  always @(posedge clk) begin
    if (~resetn)
      pkt_counter <=0 ;
    else
      if (exa.footer_valid & exa.footer_ready)
        if (pkt_counter == 127)//it was 63
          pkt_counter <= 0;
        else
          pkt_counter <= pkt_counter + 1 ;        
  end
  
  wire [127:0] paylod ;
  baket_info_t baket_info;
  
  assign baket_info.src       = src_q;
  assign baket_info.dst       = dst_q ;
  assign baket_info.prio      = prio_q;
  assign baket_info.timestamp = timestamp_q ;
  assign paylod               = {32'hDEAD_BEEF,rand_32,rand_32,32'hDEAD_BEEF};
 
  
  
  assign exa.data  = (state_q == HEADER) ? exa_header_t : 
                     (state_q == FOOTER) ? exa_footer_t :
                                           paylod;
  assign exa.header_valid  = (state_q == HEADER);
  assign exa.payload_valid = ((state_q == PAYLOAD) & (rand_5 >= valid_drop_rate) );
  assign exa.footer_valid  = (state_q == FOOTER);

  assign exa_footer_t.pld_crc       = pkt_counter;	//payload error detection
  assign exa_footer_t.footer_crc    = 0;		    //footer error detection
  assign exa_footer_t.user_bits     = 0;		    //user info bits
  assign exa_footer_t.ttl           = 0;			//time to leave
  assign exa_footer_t.seq_num       = 0;			//sequence number
  assign exa_footer_t.notif_enable  = 0;		    //completion notification enable 
  assign exa_footer_t.last_p        = 0;			//last packet flag
  assign exa_footer_t.first_p       = 0;			//first packet flag
  assign exa_footer_t.valid_flags   = 0;		    //
  assign exa_footer_t.src_coord     = i_src_coord; //source coordinate
  assign exa_footer_t.tid           = 0;     		//transaction ID

  assign exa_header_t.ecc           = pkt_counter; //error correction
  assign exa_header_t.offset        = 0;		   //offset coordinate
  assign exa_header_t.rsrv          = tag;		   //reserved
  assign exa_header_t.dest_coord    = 0;//22'b00_0000_0000_0000_0001_0010    	   //Destination Coordinate
  assign exa_header_t.pdid          = 0;           //Protection Domain  
  
   
  
  
  
  always_comb begin
    /*set the priority of the packet*/
    if (dif_type_enable)
      exa_header_t.pkt_type = (rand_7 >= chanche_for_high_priority) ? 'd20 : 'd0 ;
    else
      exa_header_t.pkt_type = 0;
     /*set the virtual channel */ 
    if(fixed_header_vc_enable)
      exa_header_t.vc = fixed_header_vc;
    else
      exa_header_t.vc = rand_5_header_vc;    
  
    /*based on that prio, set the addres (should have the 0x38 in fron or not*/
  /*  
    if (fixed_dest_enable) 
      exa_header_t.addr          = (exa_header_t.pkt_type >= 10) ?  (16*fixed_dest) + 10'h30 :
                                                                    {3'b111, 29'b0, ((10'd16*fixed_dest) + 10'h30) } ; //the second part should be 10 bits  
    else  */                                                                   
      exa_header_t.addr          = (exa_header_t.pkt_type >= 10) ?  (16*rand_2) + 10'h30 :
     
                                                                    {3'b111, 29'b0, ((10'd16*rand_2) + 10'h30) } ; //the second part should be 10 bits   
    
    if(fixed_dest_enable)begin
      exa_header_t.dest_coord = {8'b00000000,rand_2,fixed_dest_z,fixed_dest_y,fixed_dest_x};
    end
    else begin
      exa_header_t.dest_coord = {8'b00000000,rand_2,rand_4_z,rand_4_y,rand_4_x};
    end
    
    if (!dif_size_enable)
        exa_header_t.size          = 'd256;	   //packet size
    else
        exa_header_t.size          = rand_8;  
  end
  

  /*save the data of the transfer*/
  reg [41: 0]  src_q        =0;     
  reg [41: 0]  dst_q        =0;     
  reg [0:  0]  prio_q       =0;
  reg [63: 0]  timestamp_q  =0;
  reg [8 : 0]  size_q       =0;
  always @(posedge clk) begin
    if (exa.header_valid) begin
      src_q         <= i_src_coord;     
      dst_q         <= exa_header_t.addr;     
      prio_q        <= (exa_header_t.pkt_type >= 16);
      size_q        <= exa_header_t.size;
      timestamp_q   <= $time ;
    end  
  end



endmodule